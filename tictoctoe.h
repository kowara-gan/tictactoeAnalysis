#ifndef _TICTOCTOE_H

#define _TICTOCTOE_H
#include <cassert>
#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include <vector>
#include <complex>
#include <deque>
#include <string>
using namespace std;
typedef complex<int> Point;

typedef unsigned long long uint64;
typedef vector<uint64> vUint64;
typedef vector<char> vChar;
typedef unsigned char uchar;
typedef vector<uchar> vuChar;
typedef vector<short> vShort;
typedef vector<int> vInt;
//the first move is 1, the second move is -1
enum Player{
  FIRST=1, SECOND=-1
};
//The state of the squares on the board
struct Ptype{
  enum {
    EMPTY=0,
    X=1,
    O=-1,
  };
};

struct State{
    char board[3*3];//position information
    int stands[2];//number it can move
    int turn;//FIRST(1) or SECOND(-1)
    State(){
    for(int x=0;x<3;x++)
      for(int y=0;y<3;y++)
      board[x*3+y]=Ptype::EMPTY;
    stands[0]=5;
    stands[1]=4;
    turn=FIRST;
  }
  //9-digit notation of position + 2-digit notation of movablenum
  uint64 showStateNum() const{
    uint64 a=0;
    uint64 h=1;
    for(int x=0;x<3;x++)
      for(int y=0;y<3;y++){
        if(board[x*3+y]!=-1){
          a+=board[x*3+y]*h;
        }else{
          a+=2*h;
        }
        h*=10;
      }
      a+=stands[0]*h;
      a+=stands[1]*h*10;
      return a;
  }
  //Generate state from the 11-digit notation generated by showStateNum()
  State(uint64 p,bool test)
  {
    State s;
    uint64 a=p;
    for(int x=0;x<3;x++)
      for(int y=0;y<3;y++){
        char b=a%10;
        if(b==2){s.board[x*3+y]=-1;}else{s.board[x*3+y]=b;}
        a=a/10;
      }
    s.stands[0]=a%10;
    s.stands[1]=a/10%10;
    s.turn=FIRST;
    *this=s;
  }
  //Generate state from normalized position information
  State(uint64 p,Player pl=FIRST)
  {
    if(pl==FIRST) *this=makeFirstFromUint64(p);
    else *this=makeFirstFromUint64(p).rotateChangeTurnState();
  }
  static State makeFirstFromUint64(uint64 p){
    State s;
    int i=0;
    for(int x=0;x<3;x++)
      for(int y=0;y<3;y++){
	char c=(p>>(i*2))&3;
	if((c&2)!=0) c-=4;
	s.board[x*3+y]=c;
	i++;
      }
    s.stands[0]=(p>>(18))&7;
    s.stands[1]=(p>>(18+3))&7;
    s.turn=FIRST;
    return s;
  }
  //Invert turn and position information
  State rotateChangeTurnState() const
  {
    State ret;
    for(int x=0;x<3;x++)
      for(int y=0;y<3;y++)
	ret.board[x*3+y]= -board[x*3+y];
    
    ret.stands[0]=stands[1]; 
    ret.stands[1]=stands[0]; 
    ret.turn= -turn;
    return ret;
  }
  //Invert turn
  void changeTurn()
  {
    turn = -turn;
  }
  //Invert the position upside down
  void flipVertically()
  {
    State ret;
    for(int x=0;x<3;x++)
      for(int y=0;y<3;y++)
	ret.board[x*3+y]= board[(2-x)*3+y];
  ret.stands[0]=stands[0]; 
    ret.stands[1]=stands[1]; 
    *this=ret;
  }
  //Invert the position diagonally
  void flipDiagonally()
  {
    State ret;
    ret.board[0]= board[0];
	  ret.board[1]= board[3];
    ret.board[2]= board[6];
    ret.board[3]= board[1];
    ret.board[4]= board[4];
    ret.board[5]= board[7];
    ret.board[6]= board[2];
    ret.board[7]= board[5];
    ret.board[8]= board[8];
    ret.stands[0]=stands[0]; 
    ret.stands[1]=stands[1]; 
    *this=ret;
  }
  //Generate State information with 2bit
  uint64 packBit() const
  {
    assert(turn==FIRST);
    uint64 ret=0ull;
    int i=0;
    for(int x=0;x<3;x++)
      for(int y=0;y<3;y++){
	      ret|=static_cast<uint64>(board[x*3+y]&3)<<(i*2);
	      i++;
    }
    for(int j=0;j<2;j++)
      ret|=static_cast<uint64>(stands[j])<<(18+j*3);
    return ret;
  }
  //Generated State information by normalizing the seven position
  //that can be regarded as the same to the smallest number
  uint64 normalizeNum() const{
    if(turn==FIRST){
      State a = *this;
      uint64 u1=packBit();
      a.flipVertically();
      u1=std::min(u1,a.packBit());
      a.flipDiagonally();
      u1=std::min(u1,a.packBit());
      a.flipVertically();
      u1=std::min(u1,a.packBit());
      a.flipDiagonally();
      u1=std::min(u1,a.packBit());
      a.flipVertically();
      u1=std::min(u1,a.packBit());
      a.flipDiagonally();
      u1=std::min(u1,a.packBit());
      a.flipVertically();
      u1=std::min(u1,a.packBit());
      return u1;
    }
    else{
      State a=rotateChangeTurnState();
      uint64 u1=a.packBit();
      a.flipVertically();
      u1=std::min(u1,a.packBit());
      a.flipDiagonally();
      u1=std::min(u1,a.packBit());
      a.flipVertically();
      u1=std::min(u1,a.packBit());
      a.flipDiagonally();
      u1=std::min(u1,a.packBit());
      a.flipVertically();
      u1=std::min(u1,a.packBit());
      a.flipDiagonally();
      u1=std::min(u1,a.packBit());
      a.flipVertically();
      u1=std::min(u1,a.packBit());
      return u1;
    }
  }
  //Judgment if state is losing
  bool isLoseFirst() const{
    if(board[0]+board[1]+board[2]==-3||
      board[3]+board[4]+board[5]==-3||
      board[6]+board[7]+board[8]==-3||
      board[0]+board[3]+board[6]==-3||
      board[1]+board[4]+board[7]==-3||
      board[2]+board[5]+board[8]==-3||
      board[0]+board[4]+board[8]==-3||
      board[2]+board[4]+board[6]==-3
      )return true;
    return false;
  }
  //Generate all of the next normalized position
  vUint64 nextNormalizeStates() const{
    vUint64 ret;
    if(stands[0]==0)return ret;
    for(int x=0;x<3;x++)
      for(int y=0;y<3;y++){
          if(board[x*3+y]==0){
              State s(*this);
              s.board[x*3+y]=Ptype::X;
              s.stands[0]--;
              s.changeTurn();
              ret.push_back(s.normalizeNum());
          }
      }
    return ret;
  }
  //Generate all of the next position by show()
  vUint64 nextShowStates() const{
    vUint64 ret;
    if(stands[0]==0)return ret;
    for(int x=0;x<3;x++)
      for(int y=0;y<3;y++){
          if(board[x*3+y]==0){
              State s(*this);
              s.board[x*3+y]=Ptype::X;
              s.stands[0]--;
              s.changeTurn();
              ret.push_back(s.rotateChangeTurnState().showStateNum());
          }
      }
    return ret;
  }
  //Draw State properly by movablenum
  void draw() const{
    int p=1;
    if(stands[0]==stands[1])p=-1;
    for(int x=0;x<3;x++){
      std::cerr << "|";
      for(int y=0;y<3;y++){
        if(board[x*3+y]==0){
          std::cerr << " |";
        }else if(board[x*3+y]==p*1){
          std::cerr << "x|";
        }else if(board[x*3+y]==p*-1){
          std::cerr << "o|";
        }
      }
      std::cerr << std::endl;
    }
  }
};
#endif